// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: snp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_snp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_snp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_snp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_snp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_snp_2eproto;
namespace snp {
class Capabilities;
struct CapabilitiesDefaultTypeInternal;
extern CapabilitiesDefaultTypeInternal _Capabilities_default_instance_;
class Component;
struct ComponentDefaultTypeInternal;
extern ComponentDefaultTypeInternal _Component_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Property;
struct PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class Property_ValueBool;
struct Property_ValueBoolDefaultTypeInternal;
extern Property_ValueBoolDefaultTypeInternal _Property_ValueBool_default_instance_;
class Property_ValueDouble;
struct Property_ValueDoubleDefaultTypeInternal;
extern Property_ValueDoubleDefaultTypeInternal _Property_ValueDouble_default_instance_;
class Property_ValueString;
struct Property_ValueStringDefaultTypeInternal;
extern Property_ValueStringDefaultTypeInternal _Property_ValueString_default_instance_;
class Property_ValueUint32;
struct Property_ValueUint32DefaultTypeInternal;
extern Property_ValueUint32DefaultTypeInternal _Property_ValueUint32_default_instance_;
class Setup;
struct SetupDefaultTypeInternal;
extern SetupDefaultTypeInternal _Setup_default_instance_;
class StreamDataCursor;
struct StreamDataCursorDefaultTypeInternal;
extern StreamDataCursorDefaultTypeInternal _StreamDataCursor_default_instance_;
class StreamDataKeyboard;
struct StreamDataKeyboardDefaultTypeInternal;
extern StreamDataKeyboardDefaultTypeInternal _StreamDataKeyboard_default_instance_;
class StreamDataPointer;
struct StreamDataPointerDefaultTypeInternal;
extern StreamDataPointerDefaultTypeInternal _StreamDataPointer_default_instance_;
class StreamDataRaw;
struct StreamDataRawDefaultTypeInternal;
extern StreamDataRawDefaultTypeInternal _StreamDataRaw_default_instance_;
}  // namespace snp
PROTOBUF_NAMESPACE_OPEN
template<> ::snp::Capabilities* Arena::CreateMaybeMessage<::snp::Capabilities>(Arena*);
template<> ::snp::Component* Arena::CreateMaybeMessage<::snp::Component>(Arena*);
template<> ::snp::Data* Arena::CreateMaybeMessage<::snp::Data>(Arena*);
template<> ::snp::Message* Arena::CreateMaybeMessage<::snp::Message>(Arena*);
template<> ::snp::Property* Arena::CreateMaybeMessage<::snp::Property>(Arena*);
template<> ::snp::Property_ValueBool* Arena::CreateMaybeMessage<::snp::Property_ValueBool>(Arena*);
template<> ::snp::Property_ValueDouble* Arena::CreateMaybeMessage<::snp::Property_ValueDouble>(Arena*);
template<> ::snp::Property_ValueString* Arena::CreateMaybeMessage<::snp::Property_ValueString>(Arena*);
template<> ::snp::Property_ValueUint32* Arena::CreateMaybeMessage<::snp::Property_ValueUint32>(Arena*);
template<> ::snp::Setup* Arena::CreateMaybeMessage<::snp::Setup>(Arena*);
template<> ::snp::StreamDataCursor* Arena::CreateMaybeMessage<::snp::StreamDataCursor>(Arena*);
template<> ::snp::StreamDataKeyboard* Arena::CreateMaybeMessage<::snp::StreamDataKeyboard>(Arena*);
template<> ::snp::StreamDataPointer* Arena::CreateMaybeMessage<::snp::StreamDataPointer>(Arena*);
template<> ::snp::StreamDataRaw* Arena::CreateMaybeMessage<::snp::StreamDataRaw>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace snp {

enum Platform : int {
  PLATFORM_WINDOWS = 0,
  PLATFORM_LINUX = 1,
  PLATFORM_MACOS = 2,
  PLATFORM_RASPBERRY = 3,
  PLATFORM_ANDROID = 4,
  Platform_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Platform_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Platform_IsValid(int value);
constexpr Platform Platform_MIN = PLATFORM_WINDOWS;
constexpr Platform Platform_MAX = PLATFORM_ANDROID;
constexpr int Platform_ARRAYSIZE = Platform_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Platform_descriptor();
template<typename T>
inline const std::string& Platform_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Platform>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Platform_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Platform_descriptor(), enum_t_value);
}
inline bool Platform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Platform* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Platform>(
    Platform_descriptor(), name, value);
}
enum ComponentType : int {
  COMPONENT_CAPTURE_VIDEO_DRM = 0,
  COMPONENT_CAPTURE_VIDEO_X11 = 1,
  COMPONENT_CAPTURE_VIDEO_WAYLAND = 2,
  COMPONENT_CAPTURE_VIDEO_V4L = 3,
  COMPONENT_CAPTURE_VIDEO_DUMMY = 4,
  COMPONENT_INPUT_KEYBOARD_X11 = 5,
  COMPONENT_INPUT_POINTER_X11 = 6,
  COMPONENT_INPUT_CURSOR_X11 = 7,
  COMPONENT_OUTPUT_VIDEO_DISPLAY = 8,
  COMPONENT_OUTPUT_KEYBOARD_X11 = 9,
  COMPONENT_OUTPUT_POINTER_X11 = 10,
  COMPONENT_OUTPUT_CURSOR_X11 = 11,
  COMPONENT_ENCODER_OPENH264 = 12,
  COMPONENT_DECODER_OPENH264 = 13,
  COMPONENT_ENCODER_INTEL = 14,
  COMPONENT_DECODER_INTEL = 15,
  COMPONENT_ENCODER_AMD = 16,
  COMPONENT_DECODER_AMD = 17,
  COMPONENT_OUTPUT_FILE = 18,
  COMPONENT_OUTPUT_TCP = 19,
  COMPONENT_INPUT_TCP = 20,
  COMPONENT_OUTPUT_WEBSOCKET = 21,
  COMPONENT_INPUT_WEBSOCKET = 22,
  COMPONENT_ENCODER_MMAL = 23,
  COMPONENT_DECODER_MMAL = 24,
  COMPONENT_CAPTURE_GL = 25,
  COMPONENT_CAPTURE_DDA = 26,
  ComponentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ComponentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ComponentType_IsValid(int value);
constexpr ComponentType ComponentType_MIN = COMPONENT_CAPTURE_VIDEO_DRM;
constexpr ComponentType ComponentType_MAX = COMPONENT_CAPTURE_DDA;
constexpr int ComponentType_ARRAYSIZE = ComponentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ComponentType_descriptor();
template<typename T>
inline const std::string& ComponentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ComponentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ComponentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ComponentType_descriptor(), enum_t_value);
}
inline bool ComponentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ComponentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ComponentType>(
    ComponentType_descriptor(), name, value);
}
enum Command : int {
  COMMAND_START = 0,
  COMMAND_STOP = 1,
  Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Command_IsValid(int value);
constexpr Command Command_MIN = COMMAND_START;
constexpr Command Command_MAX = COMMAND_STOP;
constexpr int Command_ARRAYSIZE = Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_descriptor();
template<typename T>
inline const std::string& Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Command_descriptor(), enum_t_value);
}
inline bool Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
enum PropertyType : int {
  PROPERTY_TYPE_STRING = 0,
  PROPERTY_TYPE_BOOL = 1,
  PROPERTY_TYPE_UINT32 = 2,
  PROPERTY_TYPE_DOUBLE = 3,
  PropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PropertyType_IsValid(int value);
constexpr PropertyType PropertyType_MIN = PROPERTY_TYPE_STRING;
constexpr PropertyType PropertyType_MAX = PROPERTY_TYPE_DOUBLE;
constexpr int PropertyType_ARRAYSIZE = PropertyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropertyType_descriptor();
template<typename T>
inline const std::string& PropertyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PropertyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PropertyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PropertyType_descriptor(), enum_t_value);
}
inline bool PropertyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PropertyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PropertyType>(
    PropertyType_descriptor(), name, value);
}
enum MessageType : int {
  MESSAGE_TYPE_SETUP = 0,
  MESSAGE_TYPE_DATA = 1,
  MESSAGE_TYPE_CAPABILITIES = 2,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = MESSAGE_TYPE_SETUP;
constexpr MessageType MessageType_MAX = MESSAGE_TYPE_CAPABILITIES;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Property_ValueString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Property.ValueString) */ {
 public:
  inline Property_ValueString() : Property_ValueString(nullptr) {}
  ~Property_ValueString() override;
  explicit PROTOBUF_CONSTEXPR Property_ValueString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property_ValueString(const Property_ValueString& from);
  Property_ValueString(Property_ValueString&& from) noexcept
    : Property_ValueString() {
    *this = ::std::move(from);
  }

  inline Property_ValueString& operator=(const Property_ValueString& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property_ValueString& operator=(Property_ValueString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property_ValueString& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property_ValueString* internal_default_instance() {
    return reinterpret_cast<const Property_ValueString*>(
               &_Property_ValueString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Property_ValueString& a, Property_ValueString& b) {
    a.Swap(&b);
  }
  inline void Swap(Property_ValueString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property_ValueString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property_ValueString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property_ValueString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property_ValueString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property_ValueString& from) {
    Property_ValueString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property_ValueString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Property.ValueString";
  }
  protected:
  explicit Property_ValueString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:snp.Property.ValueString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Property_ValueBool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Property.ValueBool) */ {
 public:
  inline Property_ValueBool() : Property_ValueBool(nullptr) {}
  ~Property_ValueBool() override;
  explicit PROTOBUF_CONSTEXPR Property_ValueBool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property_ValueBool(const Property_ValueBool& from);
  Property_ValueBool(Property_ValueBool&& from) noexcept
    : Property_ValueBool() {
    *this = ::std::move(from);
  }

  inline Property_ValueBool& operator=(const Property_ValueBool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property_ValueBool& operator=(Property_ValueBool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property_ValueBool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property_ValueBool* internal_default_instance() {
    return reinterpret_cast<const Property_ValueBool*>(
               &_Property_ValueBool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Property_ValueBool& a, Property_ValueBool& b) {
    a.Swap(&b);
  }
  inline void Swap(Property_ValueBool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property_ValueBool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property_ValueBool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property_ValueBool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property_ValueBool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property_ValueBool& from) {
    Property_ValueBool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property_ValueBool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Property.ValueBool";
  }
  protected:
  explicit Property_ValueBool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:snp.Property.ValueBool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Property_ValueUint32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Property.ValueUint32) */ {
 public:
  inline Property_ValueUint32() : Property_ValueUint32(nullptr) {}
  ~Property_ValueUint32() override;
  explicit PROTOBUF_CONSTEXPR Property_ValueUint32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property_ValueUint32(const Property_ValueUint32& from);
  Property_ValueUint32(Property_ValueUint32&& from) noexcept
    : Property_ValueUint32() {
    *this = ::std::move(from);
  }

  inline Property_ValueUint32& operator=(const Property_ValueUint32& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property_ValueUint32& operator=(Property_ValueUint32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property_ValueUint32& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property_ValueUint32* internal_default_instance() {
    return reinterpret_cast<const Property_ValueUint32*>(
               &_Property_ValueUint32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Property_ValueUint32& a, Property_ValueUint32& b) {
    a.Swap(&b);
  }
  inline void Swap(Property_ValueUint32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property_ValueUint32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property_ValueUint32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property_ValueUint32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property_ValueUint32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property_ValueUint32& from) {
    Property_ValueUint32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property_ValueUint32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Property.ValueUint32";
  }
  protected:
  explicit Property_ValueUint32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  // uint32 value = 1;
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // optional uint32 min = 2;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  uint32_t min() const;
  void set_min(uint32_t value);
  private:
  uint32_t _internal_min() const;
  void _internal_set_min(uint32_t value);
  public:

  // optional uint32 max = 3;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  uint32_t max() const;
  void set_max(uint32_t value);
  private:
  uint32_t _internal_max() const;
  void _internal_set_max(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:snp.Property.ValueUint32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t value_;
    uint32_t min_;
    uint32_t max_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Property_ValueDouble final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Property.ValueDouble) */ {
 public:
  inline Property_ValueDouble() : Property_ValueDouble(nullptr) {}
  ~Property_ValueDouble() override;
  explicit PROTOBUF_CONSTEXPR Property_ValueDouble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property_ValueDouble(const Property_ValueDouble& from);
  Property_ValueDouble(Property_ValueDouble&& from) noexcept
    : Property_ValueDouble() {
    *this = ::std::move(from);
  }

  inline Property_ValueDouble& operator=(const Property_ValueDouble& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property_ValueDouble& operator=(Property_ValueDouble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property_ValueDouble& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property_ValueDouble* internal_default_instance() {
    return reinterpret_cast<const Property_ValueDouble*>(
               &_Property_ValueDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Property_ValueDouble& a, Property_ValueDouble& b) {
    a.Swap(&b);
  }
  inline void Swap(Property_ValueDouble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property_ValueDouble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property_ValueDouble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property_ValueDouble>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property_ValueDouble& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property_ValueDouble& from) {
    Property_ValueDouble::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property_ValueDouble* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Property.ValueDouble";
  }
  protected:
  explicit Property_ValueDouble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  // double value = 1;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // optional double min = 2;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  double min() const;
  void set_min(double value);
  private:
  double _internal_min() const;
  void _internal_set_min(double value);
  public:

  // optional double max = 3;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  double max() const;
  void set_max(double value);
  private:
  double _internal_max() const;
  void _internal_set_max(double value);
  public:

  // @@protoc_insertion_point(class_scope:snp.Property.ValueDouble)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double value_;
    double min_;
    double max_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Property final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Property) */ {
 public:
  inline Property() : Property(nullptr) {}
  ~Property() override;
  explicit PROTOBUF_CONSTEXPR Property(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property(const Property& from);
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property& operator=(Property&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kValueString = 3,
    kValueBool = 4,
    kValueUint32 = 5,
    kValueDouble = 6,
    VALUE_NOT_SET = 0,
  };

  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }
  inline void Swap(Property* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property& from) {
    Property::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Property";
  }
  protected:
  explicit Property(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Property_ValueString ValueString;
  typedef Property_ValueBool ValueBool;
  typedef Property_ValueUint32 ValueUint32;
  typedef Property_ValueDouble ValueDouble;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
    kValueStringFieldNumber = 3,
    kValueBoolFieldNumber = 4,
    kValueUint32FieldNumber = 5,
    kValueDoubleFieldNumber = 6,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .snp.PropertyType type = 1;
  void clear_type();
  ::snp::PropertyType type() const;
  void set_type(::snp::PropertyType value);
  private:
  ::snp::PropertyType _internal_type() const;
  void _internal_set_type(::snp::PropertyType value);
  public:

  // .snp.Property.ValueString value_string = 3;
  bool has_value_string() const;
  private:
  bool _internal_has_value_string() const;
  public:
  void clear_value_string();
  const ::snp::Property_ValueString& value_string() const;
  PROTOBUF_NODISCARD ::snp::Property_ValueString* release_value_string();
  ::snp::Property_ValueString* mutable_value_string();
  void set_allocated_value_string(::snp::Property_ValueString* value_string);
  private:
  const ::snp::Property_ValueString& _internal_value_string() const;
  ::snp::Property_ValueString* _internal_mutable_value_string();
  public:
  void unsafe_arena_set_allocated_value_string(
      ::snp::Property_ValueString* value_string);
  ::snp::Property_ValueString* unsafe_arena_release_value_string();

  // .snp.Property.ValueBool value_bool = 4;
  bool has_value_bool() const;
  private:
  bool _internal_has_value_bool() const;
  public:
  void clear_value_bool();
  const ::snp::Property_ValueBool& value_bool() const;
  PROTOBUF_NODISCARD ::snp::Property_ValueBool* release_value_bool();
  ::snp::Property_ValueBool* mutable_value_bool();
  void set_allocated_value_bool(::snp::Property_ValueBool* value_bool);
  private:
  const ::snp::Property_ValueBool& _internal_value_bool() const;
  ::snp::Property_ValueBool* _internal_mutable_value_bool();
  public:
  void unsafe_arena_set_allocated_value_bool(
      ::snp::Property_ValueBool* value_bool);
  ::snp::Property_ValueBool* unsafe_arena_release_value_bool();

  // .snp.Property.ValueUint32 value_uint32 = 5;
  bool has_value_uint32() const;
  private:
  bool _internal_has_value_uint32() const;
  public:
  void clear_value_uint32();
  const ::snp::Property_ValueUint32& value_uint32() const;
  PROTOBUF_NODISCARD ::snp::Property_ValueUint32* release_value_uint32();
  ::snp::Property_ValueUint32* mutable_value_uint32();
  void set_allocated_value_uint32(::snp::Property_ValueUint32* value_uint32);
  private:
  const ::snp::Property_ValueUint32& _internal_value_uint32() const;
  ::snp::Property_ValueUint32* _internal_mutable_value_uint32();
  public:
  void unsafe_arena_set_allocated_value_uint32(
      ::snp::Property_ValueUint32* value_uint32);
  ::snp::Property_ValueUint32* unsafe_arena_release_value_uint32();

  // .snp.Property.ValueDouble value_double = 6;
  bool has_value_double() const;
  private:
  bool _internal_has_value_double() const;
  public:
  void clear_value_double();
  const ::snp::Property_ValueDouble& value_double() const;
  PROTOBUF_NODISCARD ::snp::Property_ValueDouble* release_value_double();
  ::snp::Property_ValueDouble* mutable_value_double();
  void set_allocated_value_double(::snp::Property_ValueDouble* value_double);
  private:
  const ::snp::Property_ValueDouble& _internal_value_double() const;
  ::snp::Property_ValueDouble* _internal_mutable_value_double();
  public:
  void unsafe_arena_set_allocated_value_double(
      ::snp::Property_ValueDouble* value_double);
  ::snp::Property_ValueDouble* unsafe_arena_release_value_double();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:snp.Property)
 private:
  class _Internal;
  void set_has_value_string();
  void set_has_value_bool();
  void set_has_value_uint32();
  void set_has_value_double();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::snp::Property_ValueString* value_string_;
      ::snp::Property_ValueBool* value_bool_;
      ::snp::Property_ValueUint32* value_uint32_;
      ::snp::Property_ValueDouble* value_double_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Component final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Component) */ {
 public:
  inline Component() : Component(nullptr) {}
  ~Component() override;
  explicit PROTOBUF_CONSTEXPR Component(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Component(const Component& from);
  Component(Component&& from) noexcept
    : Component() {
    *this = ::std::move(from);
  }

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }
  inline Component& operator=(Component&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Component& default_instance() {
    return *internal_default_instance();
  }
  static inline const Component* internal_default_instance() {
    return reinterpret_cast<const Component*>(
               &_Component_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Component& a, Component& b) {
    a.Swap(&b);
  }
  inline void Swap(Component* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Component* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Component* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Component>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Component& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Component& from) {
    Component::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Component* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Component";
  }
  protected:
  explicit Component(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyFieldNumber = 2,
    kComponentTypeFieldNumber = 1,
  };
  // repeated .snp.Property property = 2;
  int property_size() const;
  private:
  int _internal_property_size() const;
  public:
  void clear_property();
  ::snp::Property* mutable_property(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Property >*
      mutable_property();
  private:
  const ::snp::Property& _internal_property(int index) const;
  ::snp::Property* _internal_add_property();
  public:
  const ::snp::Property& property(int index) const;
  ::snp::Property* add_property();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Property >&
      property() const;

  // .snp.ComponentType componentType = 1;
  void clear_componenttype();
  ::snp::ComponentType componenttype() const;
  void set_componenttype(::snp::ComponentType value);
  private:
  ::snp::ComponentType _internal_componenttype() const;
  void _internal_set_componenttype(::snp::ComponentType value);
  public:

  // @@protoc_insertion_point(class_scope:snp.Component)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Property > property_;
    int componenttype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Capabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Capabilities) */ {
 public:
  inline Capabilities() : Capabilities(nullptr) {}
  ~Capabilities() override;
  explicit PROTOBUF_CONSTEXPR Capabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Capabilities(const Capabilities& from);
  Capabilities(Capabilities&& from) noexcept
    : Capabilities() {
    *this = ::std::move(from);
  }

  inline Capabilities& operator=(const Capabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline Capabilities& operator=(Capabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Capabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const Capabilities* internal_default_instance() {
    return reinterpret_cast<const Capabilities*>(
               &_Capabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Capabilities& a, Capabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(Capabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Capabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Capabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Capabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Capabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Capabilities& from) {
    Capabilities::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Capabilities";
  }
  protected:
  explicit Capabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentFieldNumber = 2,
    kPlatformFieldNumber = 1,
  };
  // repeated .snp.Component component = 2;
  int component_size() const;
  private:
  int _internal_component_size() const;
  public:
  void clear_component();
  ::snp::Component* mutable_component(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >*
      mutable_component();
  private:
  const ::snp::Component& _internal_component(int index) const;
  ::snp::Component* _internal_add_component();
  public:
  const ::snp::Component& component(int index) const;
  ::snp::Component* add_component();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >&
      component() const;

  // .snp.Platform platform = 1;
  void clear_platform();
  ::snp::Platform platform() const;
  void set_platform(::snp::Platform value);
  private:
  ::snp::Platform _internal_platform() const;
  void _internal_set_platform(::snp::Platform value);
  public:

  // @@protoc_insertion_point(class_scope:snp.Capabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component > component_;
    int platform_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Setup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Setup) */ {
 public:
  inline Setup() : Setup(nullptr) {}
  ~Setup() override;
  explicit PROTOBUF_CONSTEXPR Setup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Setup(const Setup& from);
  Setup(Setup&& from) noexcept
    : Setup() {
    *this = ::std::move(from);
  }

  inline Setup& operator=(const Setup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Setup& operator=(Setup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Setup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Setup* internal_default_instance() {
    return reinterpret_cast<const Setup*>(
               &_Setup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Setup& a, Setup& b) {
    a.Swap(&b);
  }
  inline void Swap(Setup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Setup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Setup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Setup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Setup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Setup& from) {
    Setup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Setup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Setup";
  }
  protected:
  explicit Setup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentFieldNumber = 3,
    kPipeIdFieldNumber = 1,
    kCommandFieldNumber = 2,
  };
  // repeated .snp.Component component = 3;
  int component_size() const;
  private:
  int _internal_component_size() const;
  public:
  void clear_component();
  ::snp::Component* mutable_component(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >*
      mutable_component();
  private:
  const ::snp::Component& _internal_component(int index) const;
  ::snp::Component* _internal_add_component();
  public:
  const ::snp::Component& component(int index) const;
  ::snp::Component* add_component();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >&
      component() const;

  // uint32 pipe_id = 1;
  void clear_pipe_id();
  uint32_t pipe_id() const;
  void set_pipe_id(uint32_t value);
  private:
  uint32_t _internal_pipe_id() const;
  void _internal_set_pipe_id(uint32_t value);
  public:

  // .snp.Command command = 2;
  void clear_command();
  ::snp::Command command() const;
  void set_command(::snp::Command value);
  private:
  ::snp::Command _internal_command() const;
  void _internal_set_command(::snp::Command value);
  public:

  // @@protoc_insertion_point(class_scope:snp.Setup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component > component_;
    uint32_t pipe_id_;
    int command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit PROTOBUF_CONSTEXPR Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kDataRaw = 2,
    kDataPointer = 3,
    kDataKeyboard = 4,
    kDataCursor = 5,
    DATA_NOT_SET = 0,
  };

  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Data& from) {
    Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipeIdFieldNumber = 1,
    kDataRawFieldNumber = 2,
    kDataPointerFieldNumber = 3,
    kDataKeyboardFieldNumber = 4,
    kDataCursorFieldNumber = 5,
  };
  // uint32 pipe_id = 1;
  void clear_pipe_id();
  uint32_t pipe_id() const;
  void set_pipe_id(uint32_t value);
  private:
  uint32_t _internal_pipe_id() const;
  void _internal_set_pipe_id(uint32_t value);
  public:

  // .snp.StreamDataRaw dataRaw = 2;
  bool has_dataraw() const;
  private:
  bool _internal_has_dataraw() const;
  public:
  void clear_dataraw();
  const ::snp::StreamDataRaw& dataraw() const;
  PROTOBUF_NODISCARD ::snp::StreamDataRaw* release_dataraw();
  ::snp::StreamDataRaw* mutable_dataraw();
  void set_allocated_dataraw(::snp::StreamDataRaw* dataraw);
  private:
  const ::snp::StreamDataRaw& _internal_dataraw() const;
  ::snp::StreamDataRaw* _internal_mutable_dataraw();
  public:
  void unsafe_arena_set_allocated_dataraw(
      ::snp::StreamDataRaw* dataraw);
  ::snp::StreamDataRaw* unsafe_arena_release_dataraw();

  // .snp.StreamDataPointer dataPointer = 3;
  bool has_datapointer() const;
  private:
  bool _internal_has_datapointer() const;
  public:
  void clear_datapointer();
  const ::snp::StreamDataPointer& datapointer() const;
  PROTOBUF_NODISCARD ::snp::StreamDataPointer* release_datapointer();
  ::snp::StreamDataPointer* mutable_datapointer();
  void set_allocated_datapointer(::snp::StreamDataPointer* datapointer);
  private:
  const ::snp::StreamDataPointer& _internal_datapointer() const;
  ::snp::StreamDataPointer* _internal_mutable_datapointer();
  public:
  void unsafe_arena_set_allocated_datapointer(
      ::snp::StreamDataPointer* datapointer);
  ::snp::StreamDataPointer* unsafe_arena_release_datapointer();

  // .snp.StreamDataKeyboard dataKeyboard = 4;
  bool has_datakeyboard() const;
  private:
  bool _internal_has_datakeyboard() const;
  public:
  void clear_datakeyboard();
  const ::snp::StreamDataKeyboard& datakeyboard() const;
  PROTOBUF_NODISCARD ::snp::StreamDataKeyboard* release_datakeyboard();
  ::snp::StreamDataKeyboard* mutable_datakeyboard();
  void set_allocated_datakeyboard(::snp::StreamDataKeyboard* datakeyboard);
  private:
  const ::snp::StreamDataKeyboard& _internal_datakeyboard() const;
  ::snp::StreamDataKeyboard* _internal_mutable_datakeyboard();
  public:
  void unsafe_arena_set_allocated_datakeyboard(
      ::snp::StreamDataKeyboard* datakeyboard);
  ::snp::StreamDataKeyboard* unsafe_arena_release_datakeyboard();

  // .snp.StreamDataCursor dataCursor = 5;
  bool has_datacursor() const;
  private:
  bool _internal_has_datacursor() const;
  public:
  void clear_datacursor();
  const ::snp::StreamDataCursor& datacursor() const;
  PROTOBUF_NODISCARD ::snp::StreamDataCursor* release_datacursor();
  ::snp::StreamDataCursor* mutable_datacursor();
  void set_allocated_datacursor(::snp::StreamDataCursor* datacursor);
  private:
  const ::snp::StreamDataCursor& _internal_datacursor() const;
  ::snp::StreamDataCursor* _internal_mutable_datacursor();
  public:
  void unsafe_arena_set_allocated_datacursor(
      ::snp::StreamDataCursor* datacursor);
  ::snp::StreamDataCursor* unsafe_arena_release_datacursor();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:snp.Data)
 private:
  class _Internal;
  void set_has_dataraw();
  void set_has_datapointer();
  void set_has_datakeyboard();
  void set_has_datacursor();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pipe_id_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::snp::StreamDataRaw* dataraw_;
      ::snp::StreamDataPointer* datapointer_;
      ::snp::StreamDataKeyboard* datakeyboard_;
      ::snp::StreamDataCursor* datacursor_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kCapabilities = 2,
    kSetup = 3,
    kData = 4,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kCapabilitiesFieldNumber = 2,
    kSetupFieldNumber = 3,
    kDataFieldNumber = 4,
  };
  // .snp.MessageType type = 1;
  void clear_type();
  ::snp::MessageType type() const;
  void set_type(::snp::MessageType value);
  private:
  ::snp::MessageType _internal_type() const;
  void _internal_set_type(::snp::MessageType value);
  public:

  // .snp.Capabilities capabilities = 2;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::snp::Capabilities& capabilities() const;
  PROTOBUF_NODISCARD ::snp::Capabilities* release_capabilities();
  ::snp::Capabilities* mutable_capabilities();
  void set_allocated_capabilities(::snp::Capabilities* capabilities);
  private:
  const ::snp::Capabilities& _internal_capabilities() const;
  ::snp::Capabilities* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::snp::Capabilities* capabilities);
  ::snp::Capabilities* unsafe_arena_release_capabilities();

  // .snp.Setup setup = 3;
  bool has_setup() const;
  private:
  bool _internal_has_setup() const;
  public:
  void clear_setup();
  const ::snp::Setup& setup() const;
  PROTOBUF_NODISCARD ::snp::Setup* release_setup();
  ::snp::Setup* mutable_setup();
  void set_allocated_setup(::snp::Setup* setup);
  private:
  const ::snp::Setup& _internal_setup() const;
  ::snp::Setup* _internal_mutable_setup();
  public:
  void unsafe_arena_set_allocated_setup(
      ::snp::Setup* setup);
  ::snp::Setup* unsafe_arena_release_setup();

  // .snp.Data data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::snp::Data& data() const;
  PROTOBUF_NODISCARD ::snp::Data* release_data();
  ::snp::Data* mutable_data();
  void set_allocated_data(::snp::Data* data);
  private:
  const ::snp::Data& _internal_data() const;
  ::snp::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::snp::Data* data);
  ::snp::Data* unsafe_arena_release_data();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:snp.Message)
 private:
  class _Internal;
  void set_has_capabilities();
  void set_has_setup();
  void set_has_data();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::snp::Capabilities* capabilities_;
      ::snp::Setup* setup_;
      ::snp::Data* data_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class StreamDataRaw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.StreamDataRaw) */ {
 public:
  inline StreamDataRaw() : StreamDataRaw(nullptr) {}
  ~StreamDataRaw() override;
  explicit PROTOBUF_CONSTEXPR StreamDataRaw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamDataRaw(const StreamDataRaw& from);
  StreamDataRaw(StreamDataRaw&& from) noexcept
    : StreamDataRaw() {
    *this = ::std::move(from);
  }

  inline StreamDataRaw& operator=(const StreamDataRaw& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamDataRaw& operator=(StreamDataRaw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamDataRaw& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamDataRaw* internal_default_instance() {
    return reinterpret_cast<const StreamDataRaw*>(
               &_StreamDataRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StreamDataRaw& a, StreamDataRaw& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamDataRaw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamDataRaw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamDataRaw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamDataRaw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamDataRaw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamDataRaw& from) {
    StreamDataRaw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamDataRaw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.StreamDataRaw";
  }
  protected:
  explicit StreamDataRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:snp.StreamDataRaw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class StreamDataPointer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.StreamDataPointer) */ {
 public:
  inline StreamDataPointer() : StreamDataPointer(nullptr) {}
  ~StreamDataPointer() override;
  explicit PROTOBUF_CONSTEXPR StreamDataPointer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamDataPointer(const StreamDataPointer& from);
  StreamDataPointer(StreamDataPointer&& from) noexcept
    : StreamDataPointer() {
    *this = ::std::move(from);
  }

  inline StreamDataPointer& operator=(const StreamDataPointer& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamDataPointer& operator=(StreamDataPointer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamDataPointer& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamDataPointer* internal_default_instance() {
    return reinterpret_cast<const StreamDataPointer*>(
               &_StreamDataPointer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StreamDataPointer& a, StreamDataPointer& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamDataPointer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamDataPointer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamDataPointer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamDataPointer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamDataPointer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamDataPointer& from) {
    StreamDataPointer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamDataPointer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.StreamDataPointer";
  }
  protected:
  explicit StreamDataPointer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbsxFieldNumber = 1,
    kAbsyFieldNumber = 2,
    kMaskFieldNumber = 3,
  };
  // uint32 absx = 1;
  void clear_absx();
  uint32_t absx() const;
  void set_absx(uint32_t value);
  private:
  uint32_t _internal_absx() const;
  void _internal_set_absx(uint32_t value);
  public:

  // uint32 absy = 2;
  void clear_absy();
  uint32_t absy() const;
  void set_absy(uint32_t value);
  private:
  uint32_t _internal_absy() const;
  void _internal_set_absy(uint32_t value);
  public:

  // optional int32 mask = 3;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  int32_t mask() const;
  void set_mask(int32_t value);
  private:
  int32_t _internal_mask() const;
  void _internal_set_mask(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:snp.StreamDataPointer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t absx_;
    uint32_t absy_;
    int32_t mask_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class StreamDataKeyboard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.StreamDataKeyboard) */ {
 public:
  inline StreamDataKeyboard() : StreamDataKeyboard(nullptr) {}
  ~StreamDataKeyboard() override;
  explicit PROTOBUF_CONSTEXPR StreamDataKeyboard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamDataKeyboard(const StreamDataKeyboard& from);
  StreamDataKeyboard(StreamDataKeyboard&& from) noexcept
    : StreamDataKeyboard() {
    *this = ::std::move(from);
  }

  inline StreamDataKeyboard& operator=(const StreamDataKeyboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamDataKeyboard& operator=(StreamDataKeyboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamDataKeyboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamDataKeyboard* internal_default_instance() {
    return reinterpret_cast<const StreamDataKeyboard*>(
               &_StreamDataKeyboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StreamDataKeyboard& a, StreamDataKeyboard& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamDataKeyboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamDataKeyboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamDataKeyboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamDataKeyboard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamDataKeyboard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamDataKeyboard& from) {
    StreamDataKeyboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamDataKeyboard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.StreamDataKeyboard";
  }
  protected:
  explicit StreamDataKeyboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysymFieldNumber = 1,
    kKeycodeFieldNumber = 2,
    kDownFieldNumber = 3,
  };
  // uint32 keysym = 1;
  void clear_keysym();
  uint32_t keysym() const;
  void set_keysym(uint32_t value);
  private:
  uint32_t _internal_keysym() const;
  void _internal_set_keysym(uint32_t value);
  public:

  // uint32 keycode = 2;
  void clear_keycode();
  uint32_t keycode() const;
  void set_keycode(uint32_t value);
  private:
  uint32_t _internal_keycode() const;
  void _internal_set_keycode(uint32_t value);
  public:

  // bool down = 3;
  void clear_down();
  bool down() const;
  void set_down(bool value);
  private:
  bool _internal_down() const;
  void _internal_set_down(bool value);
  public:

  // @@protoc_insertion_point(class_scope:snp.StreamDataKeyboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t keysym_;
    uint32_t keycode_;
    bool down_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// -------------------------------------------------------------------

class StreamDataCursor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snp.StreamDataCursor) */ {
 public:
  inline StreamDataCursor() : StreamDataCursor(nullptr) {}
  ~StreamDataCursor() override;
  explicit PROTOBUF_CONSTEXPR StreamDataCursor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamDataCursor(const StreamDataCursor& from);
  StreamDataCursor(StreamDataCursor&& from) noexcept
    : StreamDataCursor() {
    *this = ::std::move(from);
  }

  inline StreamDataCursor& operator=(const StreamDataCursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamDataCursor& operator=(StreamDataCursor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamDataCursor& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamDataCursor* internal_default_instance() {
    return reinterpret_cast<const StreamDataCursor*>(
               &_StreamDataCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StreamDataCursor& a, StreamDataCursor& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamDataCursor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamDataCursor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamDataCursor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamDataCursor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamDataCursor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamDataCursor& from) {
    StreamDataCursor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamDataCursor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snp.StreamDataCursor";
  }
  protected:
  explicit StreamDataCursor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 5,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kHotxFieldNumber = 3,
    kHotyFieldNumber = 4,
  };
  // bytes image = 5;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // uint32 width = 1;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 2;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // uint32 hotx = 3;
  void clear_hotx();
  uint32_t hotx() const;
  void set_hotx(uint32_t value);
  private:
  uint32_t _internal_hotx() const;
  void _internal_set_hotx(uint32_t value);
  public:

  // uint32 hoty = 4;
  void clear_hoty();
  uint32_t hoty() const;
  void set_hoty(uint32_t value);
  private:
  uint32_t _internal_hoty() const;
  void _internal_set_hoty(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:snp.StreamDataCursor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    uint32_t width_;
    uint32_t height_;
    uint32_t hotx_;
    uint32_t hoty_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Property_ValueString

// string value = 1;
inline void Property_ValueString::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Property_ValueString::value() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueString.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property_ValueString::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snp.Property.ValueString.value)
}
inline std::string* Property_ValueString::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:snp.Property.ValueString.value)
  return _s;
}
inline const std::string& Property_ValueString::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Property_ValueString::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Property_ValueString::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Property_ValueString::release_value() {
  // @@protoc_insertion_point(field_release:snp.Property.ValueString.value)
  return _impl_.value_.Release();
}
inline void Property_ValueString::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snp.Property.ValueString.value)
}

// -------------------------------------------------------------------

// Property_ValueBool

// bool value = 1;
inline void Property_ValueBool::clear_value() {
  _impl_.value_ = false;
}
inline bool Property_ValueBool::_internal_value() const {
  return _impl_.value_;
}
inline bool Property_ValueBool::value() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueBool.value)
  return _internal_value();
}
inline void Property_ValueBool::_internal_set_value(bool value) {
  
  _impl_.value_ = value;
}
inline void Property_ValueBool::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:snp.Property.ValueBool.value)
}

// -------------------------------------------------------------------

// Property_ValueUint32

// uint32 value = 1;
inline void Property_ValueUint32::clear_value() {
  _impl_.value_ = 0u;
}
inline uint32_t Property_ValueUint32::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t Property_ValueUint32::value() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueUint32.value)
  return _internal_value();
}
inline void Property_ValueUint32::_internal_set_value(uint32_t value) {
  
  _impl_.value_ = value;
}
inline void Property_ValueUint32::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:snp.Property.ValueUint32.value)
}

// optional uint32 min = 2;
inline bool Property_ValueUint32::_internal_has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Property_ValueUint32::has_min() const {
  return _internal_has_min();
}
inline void Property_ValueUint32::clear_min() {
  _impl_.min_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Property_ValueUint32::_internal_min() const {
  return _impl_.min_;
}
inline uint32_t Property_ValueUint32::min() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueUint32.min)
  return _internal_min();
}
inline void Property_ValueUint32::_internal_set_min(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_ = value;
}
inline void Property_ValueUint32::set_min(uint32_t value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:snp.Property.ValueUint32.min)
}

// optional uint32 max = 3;
inline bool Property_ValueUint32::_internal_has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Property_ValueUint32::has_max() const {
  return _internal_has_max();
}
inline void Property_ValueUint32::clear_max() {
  _impl_.max_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Property_ValueUint32::_internal_max() const {
  return _impl_.max_;
}
inline uint32_t Property_ValueUint32::max() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueUint32.max)
  return _internal_max();
}
inline void Property_ValueUint32::_internal_set_max(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_ = value;
}
inline void Property_ValueUint32::set_max(uint32_t value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:snp.Property.ValueUint32.max)
}

// -------------------------------------------------------------------

// Property_ValueDouble

// double value = 1;
inline void Property_ValueDouble::clear_value() {
  _impl_.value_ = 0;
}
inline double Property_ValueDouble::_internal_value() const {
  return _impl_.value_;
}
inline double Property_ValueDouble::value() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueDouble.value)
  return _internal_value();
}
inline void Property_ValueDouble::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void Property_ValueDouble::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:snp.Property.ValueDouble.value)
}

// optional double min = 2;
inline bool Property_ValueDouble::_internal_has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Property_ValueDouble::has_min() const {
  return _internal_has_min();
}
inline void Property_ValueDouble::clear_min() {
  _impl_.min_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Property_ValueDouble::_internal_min() const {
  return _impl_.min_;
}
inline double Property_ValueDouble::min() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueDouble.min)
  return _internal_min();
}
inline void Property_ValueDouble::_internal_set_min(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_ = value;
}
inline void Property_ValueDouble::set_min(double value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:snp.Property.ValueDouble.min)
}

// optional double max = 3;
inline bool Property_ValueDouble::_internal_has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Property_ValueDouble::has_max() const {
  return _internal_has_max();
}
inline void Property_ValueDouble::clear_max() {
  _impl_.max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Property_ValueDouble::_internal_max() const {
  return _impl_.max_;
}
inline double Property_ValueDouble::max() const {
  // @@protoc_insertion_point(field_get:snp.Property.ValueDouble.max)
  return _internal_max();
}
inline void Property_ValueDouble::_internal_set_max(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_ = value;
}
inline void Property_ValueDouble::set_max(double value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:snp.Property.ValueDouble.max)
}

// -------------------------------------------------------------------

// Property

// .snp.PropertyType type = 1;
inline void Property::clear_type() {
  _impl_.type_ = 0;
}
inline ::snp::PropertyType Property::_internal_type() const {
  return static_cast< ::snp::PropertyType >(_impl_.type_);
}
inline ::snp::PropertyType Property::type() const {
  // @@protoc_insertion_point(field_get:snp.Property.type)
  return _internal_type();
}
inline void Property::_internal_set_type(::snp::PropertyType value) {
  
  _impl_.type_ = value;
}
inline void Property::set_type(::snp::PropertyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:snp.Property.type)
}

// string name = 2;
inline void Property::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Property::name() const {
  // @@protoc_insertion_point(field_get:snp.Property.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snp.Property.name)
}
inline std::string* Property::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:snp.Property.name)
  return _s;
}
inline const std::string& Property::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Property::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Property::release_name() {
  // @@protoc_insertion_point(field_release:snp.Property.name)
  return _impl_.name_.Release();
}
inline void Property::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snp.Property.name)
}

// .snp.Property.ValueString value_string = 3;
inline bool Property::_internal_has_value_string() const {
  return value_case() == kValueString;
}
inline bool Property::has_value_string() const {
  return _internal_has_value_string();
}
inline void Property::set_has_value_string() {
  _impl_._oneof_case_[0] = kValueString;
}
inline void Property::clear_value_string() {
  if (_internal_has_value_string()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.value_string_;
    }
    clear_has_value();
  }
}
inline ::snp::Property_ValueString* Property::release_value_string() {
  // @@protoc_insertion_point(field_release:snp.Property.value_string)
  if (_internal_has_value_string()) {
    clear_has_value();
    ::snp::Property_ValueString* temp = _impl_.value_.value_string_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.value_string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::Property_ValueString& Property::_internal_value_string() const {
  return _internal_has_value_string()
      ? *_impl_.value_.value_string_
      : reinterpret_cast< ::snp::Property_ValueString&>(::snp::_Property_ValueString_default_instance_);
}
inline const ::snp::Property_ValueString& Property::value_string() const {
  // @@protoc_insertion_point(field_get:snp.Property.value_string)
  return _internal_value_string();
}
inline ::snp::Property_ValueString* Property::unsafe_arena_release_value_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Property.value_string)
  if (_internal_has_value_string()) {
    clear_has_value();
    ::snp::Property_ValueString* temp = _impl_.value_.value_string_;
    _impl_.value_.value_string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Property::unsafe_arena_set_allocated_value_string(::snp::Property_ValueString* value_string) {
  clear_value();
  if (value_string) {
    set_has_value_string();
    _impl_.value_.value_string_ = value_string;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Property.value_string)
}
inline ::snp::Property_ValueString* Property::_internal_mutable_value_string() {
  if (!_internal_has_value_string()) {
    clear_value();
    set_has_value_string();
    _impl_.value_.value_string_ = CreateMaybeMessage< ::snp::Property_ValueString >(GetArenaForAllocation());
  }
  return _impl_.value_.value_string_;
}
inline ::snp::Property_ValueString* Property::mutable_value_string() {
  ::snp::Property_ValueString* _msg = _internal_mutable_value_string();
  // @@protoc_insertion_point(field_mutable:snp.Property.value_string)
  return _msg;
}

// .snp.Property.ValueBool value_bool = 4;
inline bool Property::_internal_has_value_bool() const {
  return value_case() == kValueBool;
}
inline bool Property::has_value_bool() const {
  return _internal_has_value_bool();
}
inline void Property::set_has_value_bool() {
  _impl_._oneof_case_[0] = kValueBool;
}
inline void Property::clear_value_bool() {
  if (_internal_has_value_bool()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.value_bool_;
    }
    clear_has_value();
  }
}
inline ::snp::Property_ValueBool* Property::release_value_bool() {
  // @@protoc_insertion_point(field_release:snp.Property.value_bool)
  if (_internal_has_value_bool()) {
    clear_has_value();
    ::snp::Property_ValueBool* temp = _impl_.value_.value_bool_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.value_bool_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::Property_ValueBool& Property::_internal_value_bool() const {
  return _internal_has_value_bool()
      ? *_impl_.value_.value_bool_
      : reinterpret_cast< ::snp::Property_ValueBool&>(::snp::_Property_ValueBool_default_instance_);
}
inline const ::snp::Property_ValueBool& Property::value_bool() const {
  // @@protoc_insertion_point(field_get:snp.Property.value_bool)
  return _internal_value_bool();
}
inline ::snp::Property_ValueBool* Property::unsafe_arena_release_value_bool() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Property.value_bool)
  if (_internal_has_value_bool()) {
    clear_has_value();
    ::snp::Property_ValueBool* temp = _impl_.value_.value_bool_;
    _impl_.value_.value_bool_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Property::unsafe_arena_set_allocated_value_bool(::snp::Property_ValueBool* value_bool) {
  clear_value();
  if (value_bool) {
    set_has_value_bool();
    _impl_.value_.value_bool_ = value_bool;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Property.value_bool)
}
inline ::snp::Property_ValueBool* Property::_internal_mutable_value_bool() {
  if (!_internal_has_value_bool()) {
    clear_value();
    set_has_value_bool();
    _impl_.value_.value_bool_ = CreateMaybeMessage< ::snp::Property_ValueBool >(GetArenaForAllocation());
  }
  return _impl_.value_.value_bool_;
}
inline ::snp::Property_ValueBool* Property::mutable_value_bool() {
  ::snp::Property_ValueBool* _msg = _internal_mutable_value_bool();
  // @@protoc_insertion_point(field_mutable:snp.Property.value_bool)
  return _msg;
}

// .snp.Property.ValueUint32 value_uint32 = 5;
inline bool Property::_internal_has_value_uint32() const {
  return value_case() == kValueUint32;
}
inline bool Property::has_value_uint32() const {
  return _internal_has_value_uint32();
}
inline void Property::set_has_value_uint32() {
  _impl_._oneof_case_[0] = kValueUint32;
}
inline void Property::clear_value_uint32() {
  if (_internal_has_value_uint32()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.value_uint32_;
    }
    clear_has_value();
  }
}
inline ::snp::Property_ValueUint32* Property::release_value_uint32() {
  // @@protoc_insertion_point(field_release:snp.Property.value_uint32)
  if (_internal_has_value_uint32()) {
    clear_has_value();
    ::snp::Property_ValueUint32* temp = _impl_.value_.value_uint32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.value_uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::Property_ValueUint32& Property::_internal_value_uint32() const {
  return _internal_has_value_uint32()
      ? *_impl_.value_.value_uint32_
      : reinterpret_cast< ::snp::Property_ValueUint32&>(::snp::_Property_ValueUint32_default_instance_);
}
inline const ::snp::Property_ValueUint32& Property::value_uint32() const {
  // @@protoc_insertion_point(field_get:snp.Property.value_uint32)
  return _internal_value_uint32();
}
inline ::snp::Property_ValueUint32* Property::unsafe_arena_release_value_uint32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Property.value_uint32)
  if (_internal_has_value_uint32()) {
    clear_has_value();
    ::snp::Property_ValueUint32* temp = _impl_.value_.value_uint32_;
    _impl_.value_.value_uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Property::unsafe_arena_set_allocated_value_uint32(::snp::Property_ValueUint32* value_uint32) {
  clear_value();
  if (value_uint32) {
    set_has_value_uint32();
    _impl_.value_.value_uint32_ = value_uint32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Property.value_uint32)
}
inline ::snp::Property_ValueUint32* Property::_internal_mutable_value_uint32() {
  if (!_internal_has_value_uint32()) {
    clear_value();
    set_has_value_uint32();
    _impl_.value_.value_uint32_ = CreateMaybeMessage< ::snp::Property_ValueUint32 >(GetArenaForAllocation());
  }
  return _impl_.value_.value_uint32_;
}
inline ::snp::Property_ValueUint32* Property::mutable_value_uint32() {
  ::snp::Property_ValueUint32* _msg = _internal_mutable_value_uint32();
  // @@protoc_insertion_point(field_mutable:snp.Property.value_uint32)
  return _msg;
}

// .snp.Property.ValueDouble value_double = 6;
inline bool Property::_internal_has_value_double() const {
  return value_case() == kValueDouble;
}
inline bool Property::has_value_double() const {
  return _internal_has_value_double();
}
inline void Property::set_has_value_double() {
  _impl_._oneof_case_[0] = kValueDouble;
}
inline void Property::clear_value_double() {
  if (_internal_has_value_double()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.value_double_;
    }
    clear_has_value();
  }
}
inline ::snp::Property_ValueDouble* Property::release_value_double() {
  // @@protoc_insertion_point(field_release:snp.Property.value_double)
  if (_internal_has_value_double()) {
    clear_has_value();
    ::snp::Property_ValueDouble* temp = _impl_.value_.value_double_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.value_double_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::Property_ValueDouble& Property::_internal_value_double() const {
  return _internal_has_value_double()
      ? *_impl_.value_.value_double_
      : reinterpret_cast< ::snp::Property_ValueDouble&>(::snp::_Property_ValueDouble_default_instance_);
}
inline const ::snp::Property_ValueDouble& Property::value_double() const {
  // @@protoc_insertion_point(field_get:snp.Property.value_double)
  return _internal_value_double();
}
inline ::snp::Property_ValueDouble* Property::unsafe_arena_release_value_double() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Property.value_double)
  if (_internal_has_value_double()) {
    clear_has_value();
    ::snp::Property_ValueDouble* temp = _impl_.value_.value_double_;
    _impl_.value_.value_double_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Property::unsafe_arena_set_allocated_value_double(::snp::Property_ValueDouble* value_double) {
  clear_value();
  if (value_double) {
    set_has_value_double();
    _impl_.value_.value_double_ = value_double;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Property.value_double)
}
inline ::snp::Property_ValueDouble* Property::_internal_mutable_value_double() {
  if (!_internal_has_value_double()) {
    clear_value();
    set_has_value_double();
    _impl_.value_.value_double_ = CreateMaybeMessage< ::snp::Property_ValueDouble >(GetArenaForAllocation());
  }
  return _impl_.value_.value_double_;
}
inline ::snp::Property_ValueDouble* Property::mutable_value_double() {
  ::snp::Property_ValueDouble* _msg = _internal_mutable_value_double();
  // @@protoc_insertion_point(field_mutable:snp.Property.value_double)
  return _msg;
}

inline bool Property::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Property::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Property::ValueCase Property::value_case() const {
  return Property::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Component

// .snp.ComponentType componentType = 1;
inline void Component::clear_componenttype() {
  _impl_.componenttype_ = 0;
}
inline ::snp::ComponentType Component::_internal_componenttype() const {
  return static_cast< ::snp::ComponentType >(_impl_.componenttype_);
}
inline ::snp::ComponentType Component::componenttype() const {
  // @@protoc_insertion_point(field_get:snp.Component.componentType)
  return _internal_componenttype();
}
inline void Component::_internal_set_componenttype(::snp::ComponentType value) {
  
  _impl_.componenttype_ = value;
}
inline void Component::set_componenttype(::snp::ComponentType value) {
  _internal_set_componenttype(value);
  // @@protoc_insertion_point(field_set:snp.Component.componentType)
}

// repeated .snp.Property property = 2;
inline int Component::_internal_property_size() const {
  return _impl_.property_.size();
}
inline int Component::property_size() const {
  return _internal_property_size();
}
inline void Component::clear_property() {
  _impl_.property_.Clear();
}
inline ::snp::Property* Component::mutable_property(int index) {
  // @@protoc_insertion_point(field_mutable:snp.Component.property)
  return _impl_.property_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Property >*
Component::mutable_property() {
  // @@protoc_insertion_point(field_mutable_list:snp.Component.property)
  return &_impl_.property_;
}
inline const ::snp::Property& Component::_internal_property(int index) const {
  return _impl_.property_.Get(index);
}
inline const ::snp::Property& Component::property(int index) const {
  // @@protoc_insertion_point(field_get:snp.Component.property)
  return _internal_property(index);
}
inline ::snp::Property* Component::_internal_add_property() {
  return _impl_.property_.Add();
}
inline ::snp::Property* Component::add_property() {
  ::snp::Property* _add = _internal_add_property();
  // @@protoc_insertion_point(field_add:snp.Component.property)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Property >&
Component::property() const {
  // @@protoc_insertion_point(field_list:snp.Component.property)
  return _impl_.property_;
}

// -------------------------------------------------------------------

// Capabilities

// .snp.Platform platform = 1;
inline void Capabilities::clear_platform() {
  _impl_.platform_ = 0;
}
inline ::snp::Platform Capabilities::_internal_platform() const {
  return static_cast< ::snp::Platform >(_impl_.platform_);
}
inline ::snp::Platform Capabilities::platform() const {
  // @@protoc_insertion_point(field_get:snp.Capabilities.platform)
  return _internal_platform();
}
inline void Capabilities::_internal_set_platform(::snp::Platform value) {
  
  _impl_.platform_ = value;
}
inline void Capabilities::set_platform(::snp::Platform value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:snp.Capabilities.platform)
}

// repeated .snp.Component component = 2;
inline int Capabilities::_internal_component_size() const {
  return _impl_.component_.size();
}
inline int Capabilities::component_size() const {
  return _internal_component_size();
}
inline void Capabilities::clear_component() {
  _impl_.component_.Clear();
}
inline ::snp::Component* Capabilities::mutable_component(int index) {
  // @@protoc_insertion_point(field_mutable:snp.Capabilities.component)
  return _impl_.component_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >*
Capabilities::mutable_component() {
  // @@protoc_insertion_point(field_mutable_list:snp.Capabilities.component)
  return &_impl_.component_;
}
inline const ::snp::Component& Capabilities::_internal_component(int index) const {
  return _impl_.component_.Get(index);
}
inline const ::snp::Component& Capabilities::component(int index) const {
  // @@protoc_insertion_point(field_get:snp.Capabilities.component)
  return _internal_component(index);
}
inline ::snp::Component* Capabilities::_internal_add_component() {
  return _impl_.component_.Add();
}
inline ::snp::Component* Capabilities::add_component() {
  ::snp::Component* _add = _internal_add_component();
  // @@protoc_insertion_point(field_add:snp.Capabilities.component)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >&
Capabilities::component() const {
  // @@protoc_insertion_point(field_list:snp.Capabilities.component)
  return _impl_.component_;
}

// -------------------------------------------------------------------

// Setup

// uint32 pipe_id = 1;
inline void Setup::clear_pipe_id() {
  _impl_.pipe_id_ = 0u;
}
inline uint32_t Setup::_internal_pipe_id() const {
  return _impl_.pipe_id_;
}
inline uint32_t Setup::pipe_id() const {
  // @@protoc_insertion_point(field_get:snp.Setup.pipe_id)
  return _internal_pipe_id();
}
inline void Setup::_internal_set_pipe_id(uint32_t value) {
  
  _impl_.pipe_id_ = value;
}
inline void Setup::set_pipe_id(uint32_t value) {
  _internal_set_pipe_id(value);
  // @@protoc_insertion_point(field_set:snp.Setup.pipe_id)
}

// .snp.Command command = 2;
inline void Setup::clear_command() {
  _impl_.command_ = 0;
}
inline ::snp::Command Setup::_internal_command() const {
  return static_cast< ::snp::Command >(_impl_.command_);
}
inline ::snp::Command Setup::command() const {
  // @@protoc_insertion_point(field_get:snp.Setup.command)
  return _internal_command();
}
inline void Setup::_internal_set_command(::snp::Command value) {
  
  _impl_.command_ = value;
}
inline void Setup::set_command(::snp::Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:snp.Setup.command)
}

// repeated .snp.Component component = 3;
inline int Setup::_internal_component_size() const {
  return _impl_.component_.size();
}
inline int Setup::component_size() const {
  return _internal_component_size();
}
inline void Setup::clear_component() {
  _impl_.component_.Clear();
}
inline ::snp::Component* Setup::mutable_component(int index) {
  // @@protoc_insertion_point(field_mutable:snp.Setup.component)
  return _impl_.component_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >*
Setup::mutable_component() {
  // @@protoc_insertion_point(field_mutable_list:snp.Setup.component)
  return &_impl_.component_;
}
inline const ::snp::Component& Setup::_internal_component(int index) const {
  return _impl_.component_.Get(index);
}
inline const ::snp::Component& Setup::component(int index) const {
  // @@protoc_insertion_point(field_get:snp.Setup.component)
  return _internal_component(index);
}
inline ::snp::Component* Setup::_internal_add_component() {
  return _impl_.component_.Add();
}
inline ::snp::Component* Setup::add_component() {
  ::snp::Component* _add = _internal_add_component();
  // @@protoc_insertion_point(field_add:snp.Setup.component)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snp::Component >&
Setup::component() const {
  // @@protoc_insertion_point(field_list:snp.Setup.component)
  return _impl_.component_;
}

// -------------------------------------------------------------------

// Data

// uint32 pipe_id = 1;
inline void Data::clear_pipe_id() {
  _impl_.pipe_id_ = 0u;
}
inline uint32_t Data::_internal_pipe_id() const {
  return _impl_.pipe_id_;
}
inline uint32_t Data::pipe_id() const {
  // @@protoc_insertion_point(field_get:snp.Data.pipe_id)
  return _internal_pipe_id();
}
inline void Data::_internal_set_pipe_id(uint32_t value) {
  
  _impl_.pipe_id_ = value;
}
inline void Data::set_pipe_id(uint32_t value) {
  _internal_set_pipe_id(value);
  // @@protoc_insertion_point(field_set:snp.Data.pipe_id)
}

// .snp.StreamDataRaw dataRaw = 2;
inline bool Data::_internal_has_dataraw() const {
  return data_case() == kDataRaw;
}
inline bool Data::has_dataraw() const {
  return _internal_has_dataraw();
}
inline void Data::set_has_dataraw() {
  _impl_._oneof_case_[0] = kDataRaw;
}
inline void Data::clear_dataraw() {
  if (_internal_has_dataraw()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.dataraw_;
    }
    clear_has_data();
  }
}
inline ::snp::StreamDataRaw* Data::release_dataraw() {
  // @@protoc_insertion_point(field_release:snp.Data.dataRaw)
  if (_internal_has_dataraw()) {
    clear_has_data();
    ::snp::StreamDataRaw* temp = _impl_.data_.dataraw_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.dataraw_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::StreamDataRaw& Data::_internal_dataraw() const {
  return _internal_has_dataraw()
      ? *_impl_.data_.dataraw_
      : reinterpret_cast< ::snp::StreamDataRaw&>(::snp::_StreamDataRaw_default_instance_);
}
inline const ::snp::StreamDataRaw& Data::dataraw() const {
  // @@protoc_insertion_point(field_get:snp.Data.dataRaw)
  return _internal_dataraw();
}
inline ::snp::StreamDataRaw* Data::unsafe_arena_release_dataraw() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Data.dataRaw)
  if (_internal_has_dataraw()) {
    clear_has_data();
    ::snp::StreamDataRaw* temp = _impl_.data_.dataraw_;
    _impl_.data_.dataraw_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Data::unsafe_arena_set_allocated_dataraw(::snp::StreamDataRaw* dataraw) {
  clear_data();
  if (dataraw) {
    set_has_dataraw();
    _impl_.data_.dataraw_ = dataraw;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Data.dataRaw)
}
inline ::snp::StreamDataRaw* Data::_internal_mutable_dataraw() {
  if (!_internal_has_dataraw()) {
    clear_data();
    set_has_dataraw();
    _impl_.data_.dataraw_ = CreateMaybeMessage< ::snp::StreamDataRaw >(GetArenaForAllocation());
  }
  return _impl_.data_.dataraw_;
}
inline ::snp::StreamDataRaw* Data::mutable_dataraw() {
  ::snp::StreamDataRaw* _msg = _internal_mutable_dataraw();
  // @@protoc_insertion_point(field_mutable:snp.Data.dataRaw)
  return _msg;
}

// .snp.StreamDataPointer dataPointer = 3;
inline bool Data::_internal_has_datapointer() const {
  return data_case() == kDataPointer;
}
inline bool Data::has_datapointer() const {
  return _internal_has_datapointer();
}
inline void Data::set_has_datapointer() {
  _impl_._oneof_case_[0] = kDataPointer;
}
inline void Data::clear_datapointer() {
  if (_internal_has_datapointer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.datapointer_;
    }
    clear_has_data();
  }
}
inline ::snp::StreamDataPointer* Data::release_datapointer() {
  // @@protoc_insertion_point(field_release:snp.Data.dataPointer)
  if (_internal_has_datapointer()) {
    clear_has_data();
    ::snp::StreamDataPointer* temp = _impl_.data_.datapointer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.datapointer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::StreamDataPointer& Data::_internal_datapointer() const {
  return _internal_has_datapointer()
      ? *_impl_.data_.datapointer_
      : reinterpret_cast< ::snp::StreamDataPointer&>(::snp::_StreamDataPointer_default_instance_);
}
inline const ::snp::StreamDataPointer& Data::datapointer() const {
  // @@protoc_insertion_point(field_get:snp.Data.dataPointer)
  return _internal_datapointer();
}
inline ::snp::StreamDataPointer* Data::unsafe_arena_release_datapointer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Data.dataPointer)
  if (_internal_has_datapointer()) {
    clear_has_data();
    ::snp::StreamDataPointer* temp = _impl_.data_.datapointer_;
    _impl_.data_.datapointer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Data::unsafe_arena_set_allocated_datapointer(::snp::StreamDataPointer* datapointer) {
  clear_data();
  if (datapointer) {
    set_has_datapointer();
    _impl_.data_.datapointer_ = datapointer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Data.dataPointer)
}
inline ::snp::StreamDataPointer* Data::_internal_mutable_datapointer() {
  if (!_internal_has_datapointer()) {
    clear_data();
    set_has_datapointer();
    _impl_.data_.datapointer_ = CreateMaybeMessage< ::snp::StreamDataPointer >(GetArenaForAllocation());
  }
  return _impl_.data_.datapointer_;
}
inline ::snp::StreamDataPointer* Data::mutable_datapointer() {
  ::snp::StreamDataPointer* _msg = _internal_mutable_datapointer();
  // @@protoc_insertion_point(field_mutable:snp.Data.dataPointer)
  return _msg;
}

// .snp.StreamDataKeyboard dataKeyboard = 4;
inline bool Data::_internal_has_datakeyboard() const {
  return data_case() == kDataKeyboard;
}
inline bool Data::has_datakeyboard() const {
  return _internal_has_datakeyboard();
}
inline void Data::set_has_datakeyboard() {
  _impl_._oneof_case_[0] = kDataKeyboard;
}
inline void Data::clear_datakeyboard() {
  if (_internal_has_datakeyboard()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.datakeyboard_;
    }
    clear_has_data();
  }
}
inline ::snp::StreamDataKeyboard* Data::release_datakeyboard() {
  // @@protoc_insertion_point(field_release:snp.Data.dataKeyboard)
  if (_internal_has_datakeyboard()) {
    clear_has_data();
    ::snp::StreamDataKeyboard* temp = _impl_.data_.datakeyboard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.datakeyboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::StreamDataKeyboard& Data::_internal_datakeyboard() const {
  return _internal_has_datakeyboard()
      ? *_impl_.data_.datakeyboard_
      : reinterpret_cast< ::snp::StreamDataKeyboard&>(::snp::_StreamDataKeyboard_default_instance_);
}
inline const ::snp::StreamDataKeyboard& Data::datakeyboard() const {
  // @@protoc_insertion_point(field_get:snp.Data.dataKeyboard)
  return _internal_datakeyboard();
}
inline ::snp::StreamDataKeyboard* Data::unsafe_arena_release_datakeyboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Data.dataKeyboard)
  if (_internal_has_datakeyboard()) {
    clear_has_data();
    ::snp::StreamDataKeyboard* temp = _impl_.data_.datakeyboard_;
    _impl_.data_.datakeyboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Data::unsafe_arena_set_allocated_datakeyboard(::snp::StreamDataKeyboard* datakeyboard) {
  clear_data();
  if (datakeyboard) {
    set_has_datakeyboard();
    _impl_.data_.datakeyboard_ = datakeyboard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Data.dataKeyboard)
}
inline ::snp::StreamDataKeyboard* Data::_internal_mutable_datakeyboard() {
  if (!_internal_has_datakeyboard()) {
    clear_data();
    set_has_datakeyboard();
    _impl_.data_.datakeyboard_ = CreateMaybeMessage< ::snp::StreamDataKeyboard >(GetArenaForAllocation());
  }
  return _impl_.data_.datakeyboard_;
}
inline ::snp::StreamDataKeyboard* Data::mutable_datakeyboard() {
  ::snp::StreamDataKeyboard* _msg = _internal_mutable_datakeyboard();
  // @@protoc_insertion_point(field_mutable:snp.Data.dataKeyboard)
  return _msg;
}

// .snp.StreamDataCursor dataCursor = 5;
inline bool Data::_internal_has_datacursor() const {
  return data_case() == kDataCursor;
}
inline bool Data::has_datacursor() const {
  return _internal_has_datacursor();
}
inline void Data::set_has_datacursor() {
  _impl_._oneof_case_[0] = kDataCursor;
}
inline void Data::clear_datacursor() {
  if (_internal_has_datacursor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.datacursor_;
    }
    clear_has_data();
  }
}
inline ::snp::StreamDataCursor* Data::release_datacursor() {
  // @@protoc_insertion_point(field_release:snp.Data.dataCursor)
  if (_internal_has_datacursor()) {
    clear_has_data();
    ::snp::StreamDataCursor* temp = _impl_.data_.datacursor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.datacursor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::StreamDataCursor& Data::_internal_datacursor() const {
  return _internal_has_datacursor()
      ? *_impl_.data_.datacursor_
      : reinterpret_cast< ::snp::StreamDataCursor&>(::snp::_StreamDataCursor_default_instance_);
}
inline const ::snp::StreamDataCursor& Data::datacursor() const {
  // @@protoc_insertion_point(field_get:snp.Data.dataCursor)
  return _internal_datacursor();
}
inline ::snp::StreamDataCursor* Data::unsafe_arena_release_datacursor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Data.dataCursor)
  if (_internal_has_datacursor()) {
    clear_has_data();
    ::snp::StreamDataCursor* temp = _impl_.data_.datacursor_;
    _impl_.data_.datacursor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Data::unsafe_arena_set_allocated_datacursor(::snp::StreamDataCursor* datacursor) {
  clear_data();
  if (datacursor) {
    set_has_datacursor();
    _impl_.data_.datacursor_ = datacursor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Data.dataCursor)
}
inline ::snp::StreamDataCursor* Data::_internal_mutable_datacursor() {
  if (!_internal_has_datacursor()) {
    clear_data();
    set_has_datacursor();
    _impl_.data_.datacursor_ = CreateMaybeMessage< ::snp::StreamDataCursor >(GetArenaForAllocation());
  }
  return _impl_.data_.datacursor_;
}
inline ::snp::StreamDataCursor* Data::mutable_datacursor() {
  ::snp::StreamDataCursor* _msg = _internal_mutable_datacursor();
  // @@protoc_insertion_point(field_mutable:snp.Data.dataCursor)
  return _msg;
}

inline bool Data::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Data::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline Data::DataCase Data::data_case() const {
  return Data::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Message

// .snp.MessageType type = 1;
inline void Message::clear_type() {
  _impl_.type_ = 0;
}
inline ::snp::MessageType Message::_internal_type() const {
  return static_cast< ::snp::MessageType >(_impl_.type_);
}
inline ::snp::MessageType Message::type() const {
  // @@protoc_insertion_point(field_get:snp.Message.type)
  return _internal_type();
}
inline void Message::_internal_set_type(::snp::MessageType value) {
  
  _impl_.type_ = value;
}
inline void Message::set_type(::snp::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:snp.Message.type)
}

// .snp.Capabilities capabilities = 2;
inline bool Message::_internal_has_capabilities() const {
  return message_case() == kCapabilities;
}
inline bool Message::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void Message::set_has_capabilities() {
  _impl_._oneof_case_[0] = kCapabilities;
}
inline void Message::clear_capabilities() {
  if (_internal_has_capabilities()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.capabilities_;
    }
    clear_has_message();
  }
}
inline ::snp::Capabilities* Message::release_capabilities() {
  // @@protoc_insertion_point(field_release:snp.Message.capabilities)
  if (_internal_has_capabilities()) {
    clear_has_message();
    ::snp::Capabilities* temp = _impl_.message_.capabilities_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.capabilities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::Capabilities& Message::_internal_capabilities() const {
  return _internal_has_capabilities()
      ? *_impl_.message_.capabilities_
      : reinterpret_cast< ::snp::Capabilities&>(::snp::_Capabilities_default_instance_);
}
inline const ::snp::Capabilities& Message::capabilities() const {
  // @@protoc_insertion_point(field_get:snp.Message.capabilities)
  return _internal_capabilities();
}
inline ::snp::Capabilities* Message::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Message.capabilities)
  if (_internal_has_capabilities()) {
    clear_has_message();
    ::snp::Capabilities* temp = _impl_.message_.capabilities_;
    _impl_.message_.capabilities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_capabilities(::snp::Capabilities* capabilities) {
  clear_message();
  if (capabilities) {
    set_has_capabilities();
    _impl_.message_.capabilities_ = capabilities;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Message.capabilities)
}
inline ::snp::Capabilities* Message::_internal_mutable_capabilities() {
  if (!_internal_has_capabilities()) {
    clear_message();
    set_has_capabilities();
    _impl_.message_.capabilities_ = CreateMaybeMessage< ::snp::Capabilities >(GetArenaForAllocation());
  }
  return _impl_.message_.capabilities_;
}
inline ::snp::Capabilities* Message::mutable_capabilities() {
  ::snp::Capabilities* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:snp.Message.capabilities)
  return _msg;
}

// .snp.Setup setup = 3;
inline bool Message::_internal_has_setup() const {
  return message_case() == kSetup;
}
inline bool Message::has_setup() const {
  return _internal_has_setup();
}
inline void Message::set_has_setup() {
  _impl_._oneof_case_[0] = kSetup;
}
inline void Message::clear_setup() {
  if (_internal_has_setup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.setup_;
    }
    clear_has_message();
  }
}
inline ::snp::Setup* Message::release_setup() {
  // @@protoc_insertion_point(field_release:snp.Message.setup)
  if (_internal_has_setup()) {
    clear_has_message();
    ::snp::Setup* temp = _impl_.message_.setup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.setup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::Setup& Message::_internal_setup() const {
  return _internal_has_setup()
      ? *_impl_.message_.setup_
      : reinterpret_cast< ::snp::Setup&>(::snp::_Setup_default_instance_);
}
inline const ::snp::Setup& Message::setup() const {
  // @@protoc_insertion_point(field_get:snp.Message.setup)
  return _internal_setup();
}
inline ::snp::Setup* Message::unsafe_arena_release_setup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Message.setup)
  if (_internal_has_setup()) {
    clear_has_message();
    ::snp::Setup* temp = _impl_.message_.setup_;
    _impl_.message_.setup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_setup(::snp::Setup* setup) {
  clear_message();
  if (setup) {
    set_has_setup();
    _impl_.message_.setup_ = setup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Message.setup)
}
inline ::snp::Setup* Message::_internal_mutable_setup() {
  if (!_internal_has_setup()) {
    clear_message();
    set_has_setup();
    _impl_.message_.setup_ = CreateMaybeMessage< ::snp::Setup >(GetArenaForAllocation());
  }
  return _impl_.message_.setup_;
}
inline ::snp::Setup* Message::mutable_setup() {
  ::snp::Setup* _msg = _internal_mutable_setup();
  // @@protoc_insertion_point(field_mutable:snp.Message.setup)
  return _msg;
}

// .snp.Data data = 4;
inline bool Message::_internal_has_data() const {
  return message_case() == kData;
}
inline bool Message::has_data() const {
  return _internal_has_data();
}
inline void Message::set_has_data() {
  _impl_._oneof_case_[0] = kData;
}
inline void Message::clear_data() {
  if (_internal_has_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.data_;
    }
    clear_has_message();
  }
}
inline ::snp::Data* Message::release_data() {
  // @@protoc_insertion_point(field_release:snp.Message.data)
  if (_internal_has_data()) {
    clear_has_message();
    ::snp::Data* temp = _impl_.message_.data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snp::Data& Message::_internal_data() const {
  return _internal_has_data()
      ? *_impl_.message_.data_
      : reinterpret_cast< ::snp::Data&>(::snp::_Data_default_instance_);
}
inline const ::snp::Data& Message::data() const {
  // @@protoc_insertion_point(field_get:snp.Message.data)
  return _internal_data();
}
inline ::snp::Data* Message::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snp.Message.data)
  if (_internal_has_data()) {
    clear_has_message();
    ::snp::Data* temp = _impl_.message_.data_;
    _impl_.message_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_data(::snp::Data* data) {
  clear_message();
  if (data) {
    set_has_data();
    _impl_.message_.data_ = data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snp.Message.data)
}
inline ::snp::Data* Message::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_message();
    set_has_data();
    _impl_.message_.data_ = CreateMaybeMessage< ::snp::Data >(GetArenaForAllocation());
  }
  return _impl_.message_.data_;
}
inline ::snp::Data* Message::mutable_data() {
  ::snp::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:snp.Message.data)
  return _msg;
}

inline bool Message::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Message::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Message::MessageCase Message::message_case() const {
  return Message::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamDataRaw

// bytes payload = 1;
inline void StreamDataRaw::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& StreamDataRaw::payload() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataRaw.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamDataRaw::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snp.StreamDataRaw.payload)
}
inline std::string* StreamDataRaw::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:snp.StreamDataRaw.payload)
  return _s;
}
inline const std::string& StreamDataRaw::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void StreamDataRaw::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamDataRaw::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamDataRaw::release_payload() {
  // @@protoc_insertion_point(field_release:snp.StreamDataRaw.payload)
  return _impl_.payload_.Release();
}
inline void StreamDataRaw::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snp.StreamDataRaw.payload)
}

// -------------------------------------------------------------------

// StreamDataPointer

// uint32 absx = 1;
inline void StreamDataPointer::clear_absx() {
  _impl_.absx_ = 0u;
}
inline uint32_t StreamDataPointer::_internal_absx() const {
  return _impl_.absx_;
}
inline uint32_t StreamDataPointer::absx() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataPointer.absx)
  return _internal_absx();
}
inline void StreamDataPointer::_internal_set_absx(uint32_t value) {
  
  _impl_.absx_ = value;
}
inline void StreamDataPointer::set_absx(uint32_t value) {
  _internal_set_absx(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataPointer.absx)
}

// uint32 absy = 2;
inline void StreamDataPointer::clear_absy() {
  _impl_.absy_ = 0u;
}
inline uint32_t StreamDataPointer::_internal_absy() const {
  return _impl_.absy_;
}
inline uint32_t StreamDataPointer::absy() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataPointer.absy)
  return _internal_absy();
}
inline void StreamDataPointer::_internal_set_absy(uint32_t value) {
  
  _impl_.absy_ = value;
}
inline void StreamDataPointer::set_absy(uint32_t value) {
  _internal_set_absy(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataPointer.absy)
}

// optional int32 mask = 3;
inline bool StreamDataPointer::_internal_has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamDataPointer::has_mask() const {
  return _internal_has_mask();
}
inline void StreamDataPointer::clear_mask() {
  _impl_.mask_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t StreamDataPointer::_internal_mask() const {
  return _impl_.mask_;
}
inline int32_t StreamDataPointer::mask() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataPointer.mask)
  return _internal_mask();
}
inline void StreamDataPointer::_internal_set_mask(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mask_ = value;
}
inline void StreamDataPointer::set_mask(int32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataPointer.mask)
}

// -------------------------------------------------------------------

// StreamDataKeyboard

// uint32 keysym = 1;
inline void StreamDataKeyboard::clear_keysym() {
  _impl_.keysym_ = 0u;
}
inline uint32_t StreamDataKeyboard::_internal_keysym() const {
  return _impl_.keysym_;
}
inline uint32_t StreamDataKeyboard::keysym() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataKeyboard.keysym)
  return _internal_keysym();
}
inline void StreamDataKeyboard::_internal_set_keysym(uint32_t value) {
  
  _impl_.keysym_ = value;
}
inline void StreamDataKeyboard::set_keysym(uint32_t value) {
  _internal_set_keysym(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataKeyboard.keysym)
}

// uint32 keycode = 2;
inline void StreamDataKeyboard::clear_keycode() {
  _impl_.keycode_ = 0u;
}
inline uint32_t StreamDataKeyboard::_internal_keycode() const {
  return _impl_.keycode_;
}
inline uint32_t StreamDataKeyboard::keycode() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataKeyboard.keycode)
  return _internal_keycode();
}
inline void StreamDataKeyboard::_internal_set_keycode(uint32_t value) {
  
  _impl_.keycode_ = value;
}
inline void StreamDataKeyboard::set_keycode(uint32_t value) {
  _internal_set_keycode(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataKeyboard.keycode)
}

// bool down = 3;
inline void StreamDataKeyboard::clear_down() {
  _impl_.down_ = false;
}
inline bool StreamDataKeyboard::_internal_down() const {
  return _impl_.down_;
}
inline bool StreamDataKeyboard::down() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataKeyboard.down)
  return _internal_down();
}
inline void StreamDataKeyboard::_internal_set_down(bool value) {
  
  _impl_.down_ = value;
}
inline void StreamDataKeyboard::set_down(bool value) {
  _internal_set_down(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataKeyboard.down)
}

// -------------------------------------------------------------------

// StreamDataCursor

// uint32 width = 1;
inline void StreamDataCursor::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t StreamDataCursor::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t StreamDataCursor::width() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataCursor.width)
  return _internal_width();
}
inline void StreamDataCursor::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void StreamDataCursor::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataCursor.width)
}

// uint32 height = 2;
inline void StreamDataCursor::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t StreamDataCursor::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t StreamDataCursor::height() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataCursor.height)
  return _internal_height();
}
inline void StreamDataCursor::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void StreamDataCursor::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataCursor.height)
}

// uint32 hotx = 3;
inline void StreamDataCursor::clear_hotx() {
  _impl_.hotx_ = 0u;
}
inline uint32_t StreamDataCursor::_internal_hotx() const {
  return _impl_.hotx_;
}
inline uint32_t StreamDataCursor::hotx() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataCursor.hotx)
  return _internal_hotx();
}
inline void StreamDataCursor::_internal_set_hotx(uint32_t value) {
  
  _impl_.hotx_ = value;
}
inline void StreamDataCursor::set_hotx(uint32_t value) {
  _internal_set_hotx(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataCursor.hotx)
}

// uint32 hoty = 4;
inline void StreamDataCursor::clear_hoty() {
  _impl_.hoty_ = 0u;
}
inline uint32_t StreamDataCursor::_internal_hoty() const {
  return _impl_.hoty_;
}
inline uint32_t StreamDataCursor::hoty() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataCursor.hoty)
  return _internal_hoty();
}
inline void StreamDataCursor::_internal_set_hoty(uint32_t value) {
  
  _impl_.hoty_ = value;
}
inline void StreamDataCursor::set_hoty(uint32_t value) {
  _internal_set_hoty(value);
  // @@protoc_insertion_point(field_set:snp.StreamDataCursor.hoty)
}

// bytes image = 5;
inline void StreamDataCursor::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& StreamDataCursor::image() const {
  // @@protoc_insertion_point(field_get:snp.StreamDataCursor.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamDataCursor::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snp.StreamDataCursor.image)
}
inline std::string* StreamDataCursor::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:snp.StreamDataCursor.image)
  return _s;
}
inline const std::string& StreamDataCursor::_internal_image() const {
  return _impl_.image_.Get();
}
inline void StreamDataCursor::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamDataCursor::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamDataCursor::release_image() {
  // @@protoc_insertion_point(field_release:snp.StreamDataCursor.image)
  return _impl_.image_.Release();
}
inline void StreamDataCursor::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snp.StreamDataCursor.image)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace snp

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::snp::Platform> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snp::Platform>() {
  return ::snp::Platform_descriptor();
}
template <> struct is_proto_enum< ::snp::ComponentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snp::ComponentType>() {
  return ::snp::ComponentType_descriptor();
}
template <> struct is_proto_enum< ::snp::Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snp::Command>() {
  return ::snp::Command_descriptor();
}
template <> struct is_proto_enum< ::snp::PropertyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snp::PropertyType>() {
  return ::snp::PropertyType_descriptor();
}
template <> struct is_proto_enum< ::snp::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snp::MessageType>() {
  return ::snp::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_snp_2eproto
